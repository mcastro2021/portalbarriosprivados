"""
Base de conocimiento del barrio para el chatbot inteligente
Contiene reglamentos, horarios, contactos y procedimientos
"""

from datetime import datetime, timedelta
import re

class BarrioKnowledgeBase:
    """Base de conocimiento espec√≠fica del barrio"""
    
    def __init__(self):
        self.reglamentos = {
            'pileta': {
                'titulo': 'Construcci√≥n de Piletas',
                'contenido': """
                Para construir una pileta debes:
                1. Solicitar autorizaci√≥n al consorcio con planos
                2. Cumplir distancias m√≠nimas: 3m del fondo, 2m laterales
                3. Sistema de filtrado silencioso
                4. Cerco perimetral obligatorio (min 1.2m altura)
                5. Horario de construcci√≥n: 8:00-18:00 d√≠as h√°biles
                6. Seguro de responsabilidad civil vigente
                """,
                'contacto': 'administracion@barrio.com',
                'tiempo_aprobacion': '15-30 d√≠as h√°biles'
            },
            'construccion': {
                'titulo': 'Obras y Construcciones',
                'contenido': """
                Reglamento general de construcciones:
                1. Autorizaci√≥n previa obligatoria
                2. Horarios: Lunes a Viernes 8:00-18:00, S√°bados 9:00-13:00
                3. No se permite trabajo domingos y feriados
                4. Altura m√°xima: 2 pisos + mansarda
                5. Retiros: Frente 5m, laterales 3m, fondo 3m
                6. Factor de ocupaci√≥n m√°ximo: 60%
                """,
                'multa_incumplimiento': '$50,000 por d√≠a'
            },
            'mascotas': {
                'titulo': 'Reglamento de Mascotas',
                'contenido': """
                1. M√°ximo 2 mascotas por lote
                2. Siempre con correa en espacios comunes
                3. Recoger excrementos obligatorio
                4. Horario de paseo en quincho: 7:00-9:00 y 19:00-21:00
                5. Vacunas al d√≠a (presentar certificado anual)
                6. Prohibido ladridos excesivos (22:00-8:00)
                """,
                'multa': '$15,000 por infracci√≥n'
            },
            'ruidos': {
                'titulo': 'Reglamento de Ruidos',
                'contenido': """
                Horarios de silencio:
                - Lunes a Jueves: 22:00 - 8:00
                - Viernes y S√°bados: 24:00 - 8:00
                - Domingos: 22:00 - 10:00
                
                Prohibido:
                - M√∫sica alta fuera de horarios
                - Herramientas ruidosas en horarios de silencio
                - Fiestas sin autorizaci√≥n previa
                """,
                'excepcion': 'Fiestas autorizadas hasta 2:00 AM m√°ximo 2 veces/a√±o'
            }
        }
        
        self.horarios = {
            'administracion': {
                'horario': 'Lunes a Viernes 9:00-17:00',
                'telefono': '+54 11 4444-5555',
                'email': 'administracion@barrio.com',
                'whatsapp': '+54 9 11 4444-5555'
            },
            'seguridad': {
                'horario': '24/7 todos los d√≠as',
                'telefono': '+54 11 4444-5556',
                'emergencias': '911 o +54 11 4444-5556'
            },
            'mantenimiento': {
                'horario': 'Lunes a Viernes 8:00-16:00',
                'telefono': '+54 11 4444-5557',
                'email': 'mantenimiento@barrio.com'
            },
            'quincho': {
                'horario_reservas': 'Lunes a Domingos 10:00-22:00',
                'horario_uso': 'Hasta 24:00 (Viernes/S√°bado hasta 2:00)',
                'capacidad': '80 personas m√°ximo',
                'precio': '$25,000/d√≠a'
            },
            'cancha_tenis': {
                'horario': '8:00-22:00 todos los d√≠as',
                'reserva_maxima': '2 horas consecutivas',
                'precio': '$5,000/hora',
                'iluminacion': 'Incluida hasta 22:00'
            },
            'pileta_comunitaria': {
                'temporada': 'Octubre - Abril',
                'horario': '10:00-20:00',
                'capacidad': '50 personas',
                'guardavidas': 'Obligatorio - incluido'
            }
        }
        
        self.contactos = {
            'emergencias': {
                'policia': '911',
                'bomberos': '100',
                'ambulancia': '107',
                'seguridad_barrio': '+54 11 4444-5556'
            },
            'servicios': {
                'administracion': '+54 11 4444-5555',
                'mantenimiento': '+54 11 4444-5557',
                'limpieza': '+54 11 4444-5558',
                'jardineria': '+54 11 4444-5559'
            },
            'consorcio': {
                'presidente': 'Carlos Mendez - carlos.mendez@email.com',
                'secretario': 'Ana Rodriguez - ana.rodriguez@email.com',
                'tesorero': 'Luis Garc√≠a - luis.garcia@email.com'
            }
        }
        
        self.procedimientos = {
            'mudanza': {
                'aviso_previo': '48 horas',
                'horario': 'Lunes a S√°bado 8:00-18:00',
                'deposito': '$50,000 (reintegrable)',
                'contacto': 'administracion@barrio.com'
            },
            'obras_menores': {
                'definicion': 'Pintura, pisos, instalaciones internas',
                'autorizacion': 'No requerida',
                'horario': 'Lunes a Viernes 8:00-17:00, S√°bados 9:00-13:00'
            },
            'obras_mayores': {
                'definicion': 'Ampliaciones, piletas, modificaciones estructurales',
                'autorizacion': 'Obligatoria - planos y memoria t√©cnica',
                'tiempo_aprobacion': '15-30 d√≠as',
                'seguro': 'RC obligatorio m√≠nimo $10.000.000'
            }
        }

    def buscar_respuesta(self, consulta):
        """Busca respuesta en la base de conocimiento"""
        consulta_lower = consulta.lower()
        
        # Buscar en reglamentos
        for key, reglamento in self.reglamentos.items():
            if any(palabra in consulta_lower for palabra in self._get_keywords(key)):
                return self._format_reglamento_response(reglamento)
        
        # Buscar horarios
        if any(palabra in consulta_lower for palabra in ['horario', 'hora', 'cuando', 'abre', 'cierra']):
            return self._buscar_horarios(consulta_lower)
        
        # Buscar contactos
        if any(palabra in consulta_lower for palabra in ['telefono', 'contacto', 'numero', 'llamar', 'whatsapp']):
            return self._buscar_contactos(consulta_lower)
        
        # Buscar procedimientos
        if any(palabra in consulta_lower for palabra in ['como', 'proceso', 'tramite', 'procedimiento']):
            return self._buscar_procedimientos(consulta_lower)
        
        return None

    def _get_keywords(self, tipo):
        """Obtiene palabras clave para cada tipo de consulta"""
        keywords = {
            'pileta': ['pileta', 'piscina', 'construir pileta', 'swimming pool'],
            'construccion': ['construccion', 'obra', 'construir', 'ampliacion', 'edificar'],
            'mascotas': ['mascota', 'perro', 'gato', 'animal', 'pet'],
            'ruidos': ['ruido', 'musica', 'silencio', 'molestia', 'fiesta']
        }
        return keywords.get(tipo, [])

    def _format_reglamento_response(self, reglamento):
        """Formatea respuesta de reglamento"""
        response = f"üìã **{reglamento['titulo']}**\n\n{reglamento['contenido']}"
        
        if 'contacto' in reglamento:
            response += f"\nüìû **Contacto**: {reglamento['contacto']}"
        if 'tiempo_aprobacion' in reglamento:
            response += f"\n‚è±Ô∏è **Tiempo de aprobaci√≥n**: {reglamento['tiempo_aprobacion']}"
        if 'multa' in reglamento:
            response += f"\n‚ö†Ô∏è **Multa por incumplimiento**: {reglamento['multa']}"
        
        return response

    def _buscar_horarios(self, consulta):
        """Busca informaci√≥n de horarios"""
        if 'administracion' in consulta:
            info = self.horarios['administracion']
            return f"üè¢ **Administraci√≥n**\nüìÖ {info['horario']}\nüìû {info['telefono']}\nüìß {info['email']}\nüì± WhatsApp: {info['whatsapp']}"
        
        elif 'seguridad' in consulta:
            info = self.horarios['seguridad']
            return f"üõ°Ô∏è **Seguridad**\nüìÖ {info['horario']}\nüìû {info['telefono']}\nüö® Emergencias: {info['emergencias']}"
        
        elif any(palabra in consulta for palabra in ['quincho', 'salon']):
            info = self.horarios['quincho']
            return f"üèõÔ∏è **Quincho/Sal√≥n de Fiestas**\nüìÖ Reservas: {info['horario_reservas']}\nüïê Uso: {info['horario_uso']}\nüë• Capacidad: {info['capacidad']}\nüí∞ Precio: {info['precio']}"
        
        elif any(palabra in consulta for palabra in ['tenis', 'cancha']):
            info = self.horarios['cancha_tenis']
            return f"üéæ **Cancha de Tenis**\nüìÖ {info['horario']}\n‚è∞ Reserva m√°xima: {info['reserva_maxima']}\nüí∞ {info['precio']}\nüí° {info['iluminacion']}"
        
        elif 'pileta' in consulta:
            info = self.horarios['pileta_comunitaria']
            return f"üèä **Pileta Comunitaria**\nüìÖ Temporada: {info['temporada']}\nüïê Horario: {info['horario']}\nüë• Capacidad: {info['capacidad']}\nüèä‚Äç‚ôÇÔ∏è {info['guardavidas']}"
        
        return "üïê **Horarios Generales:**\n‚Ä¢ Administraci√≥n: Lun-Vie 9:00-17:00\n‚Ä¢ Seguridad: 24/7\n‚Ä¢ Mantenimiento: Lun-Vie 8:00-16:00\n‚Ä¢ Quincho: 10:00-22:00 (uso hasta 24:00)\n‚Ä¢ Cancha Tenis: 8:00-22:00"

    def _buscar_contactos(self, consulta):
        """Busca informaci√≥n de contactos"""
        if 'emergencia' in consulta:
            return "üö® **Contactos de Emergencia:**\n‚Ä¢ Polic√≠a: 911\n‚Ä¢ Bomberos: 100\n‚Ä¢ Ambulancia: 107\n‚Ä¢ Seguridad Barrio: +54 11 4444-5556"
        
        elif 'administracion' in consulta:
            return "üè¢ **Administraci√≥n:**\n‚Ä¢ Tel√©fono: +54 11 4444-5555\n‚Ä¢ Email: administracion@barrio.com\n‚Ä¢ WhatsApp: +54 9 11 4444-5555"
        
        elif 'consorcio' in consulta:
            return "üèõÔ∏è **Consorcio:**\n‚Ä¢ Presidente: Carlos Mendez - carlos.mendez@email.com\n‚Ä¢ Secretario: Ana Rodriguez - ana.rodriguez@email.com\n‚Ä¢ Tesorero: Luis Garc√≠a - luis.garcia@email.com"
        
        return "üìû **Contactos Principales:**\n‚Ä¢ Administraci√≥n: +54 11 4444-5555\n‚Ä¢ Seguridad: +54 11 4444-5556\n‚Ä¢ Mantenimiento: +54 11 4444-5557\n‚Ä¢ Emergencias: 911"

    def _buscar_procedimientos(self, consulta):
        """Busca informaci√≥n de procedimientos"""
        if 'mudanza' in consulta:
            proc = self.procedimientos['mudanza']
            return f"üì¶ **Procedimiento de Mudanza:**\n‚Ä¢ Aviso previo: {proc['aviso_previo']}\n‚Ä¢ Horario permitido: {proc['horario']}\n‚Ä¢ Dep√≥sito: {proc['deposito']}\n‚Ä¢ Contacto: {proc['contacto']}"
        
        elif any(palabra in consulta for palabra in ['obra menor', 'pintura', 'piso']):
            proc = self.procedimientos['obras_menores']
            return f"üî® **Obras Menores ({proc['definicion']}):**\n‚Ä¢ Autorizaci√≥n: {proc['autorizacion']}\n‚Ä¢ Horario: {proc['horario']}"
        
        elif any(palabra in consulta for palabra in ['obra mayor', 'ampliacion', 'pileta']):
            proc = self.procedimientos['obras_mayores']
            return f"üèóÔ∏è **Obras Mayores ({proc['definicion']}):**\n‚Ä¢ Autorizaci√≥n: {proc['autorizacion']}\n‚Ä¢ Tiempo: {proc['tiempo_aprobacion']}\n‚Ä¢ Seguro: {proc['seguro']}"
        
        return None

class BarrioDataAnalyzer:
    """Analizador de datos del barrio en tiempo real"""
    
    def __init__(self, db):
        self.db = db
    
    def get_expense_info(self, user_id):
        """Obtiene informaci√≥n de expensas del usuario"""
        from models import Expense
        
        # Expensas pendientes
        pending = Expense.query.filter_by(user_id=user_id, status='pending').all()
        overdue = Expense.query.filter_by(user_id=user_id, status='overdue').all()
        
        if not pending and not overdue:
            return "‚úÖ **Estado de Expensas:** ¬°Excelente! No tienes expensas pendientes."
        
        response = "üí≥ **Estado de tus Expensas:**\n\n"
        
        if pending:
            response += f"üìã **Pendientes ({len(pending)}):**\n"
            for exp in pending:
                response += f"‚Ä¢ Per√≠odo: {exp.period}\n‚Ä¢ Monto: ${exp.amount:,.0f}\n‚Ä¢ Vence: {exp.due_date.strftime('%d/%m/%Y')}\n\n"
        
        if overdue:
            response += f"‚ö†Ô∏è **Vencidas ({len(overdue)}):**\n"
            for exp in overdue:
                days_overdue = (datetime.now().date() - exp.due_date).days
                response += f"‚Ä¢ Per√≠odo: {exp.period}\n‚Ä¢ Monto: ${exp.amount:,.0f}\n‚Ä¢ Vencida hace: {days_overdue} d√≠as\n\n"
        
        return response.strip()
    
    def get_visits_info(self, user_id):
        """Obtiene informaci√≥n de visitas del usuario"""
        from models import Visit
        
        pending = Visit.query.filter_by(resident_id=user_id, status='pending').all()
        active = Visit.query.filter_by(resident_id=user_id, status='active').all()
        
        if not pending and not active:
            return "üë• **Visitas:** No tienes visitas pendientes ni activas en este momento."
        
        response = "üë• **Estado de tus Visitas:**\n\n"
        
        if pending:
            response += f"‚è≥ **Pendientes de autorizaci√≥n ({len(pending)}):**\n"
            for visit in pending[:3]:  # M√°ximo 3
                response += f"‚Ä¢ {visit.visitor_name} - {visit.visit_date.strftime('%d/%m/%Y')}\n"
            if len(pending) > 3:
                response += f"‚Ä¢ ... y {len(pending) - 3} m√°s\n"
            response += "\n"
        
        if active:
            response += f"‚úÖ **Autorizadas ({len(active)}):**\n"
            for visit in active[:3]:
                response += f"‚Ä¢ {visit.visitor_name} - {visit.visit_date.strftime('%d/%m/%Y')}\n"
            if len(active) > 3:
                response += f"‚Ä¢ ... y {len(active) - 3} m√°s\n"
        
        return response.strip()
    
    def get_reservations_info(self, user_id):
        """Obtiene informaci√≥n de reservas del usuario"""
        from models import Reservation
        
        pending = Reservation.query.filter_by(user_id=user_id, status='pending').all()
        approved = Reservation.query.filter_by(user_id=user_id, status='approved').all()
        
        if not pending and not approved:
            return "üìÖ **Reservas:** No tienes reservas pendientes ni confirmadas."
        
        response = "üìÖ **Estado de tus Reservas:**\n\n"
        
        if pending:
            response += f"‚è≥ **Pendientes de aprobaci√≥n ({len(pending)}):**\n"
            for res in pending:
                response += f"‚Ä¢ {res.space_type} - {res.date.strftime('%d/%m/%Y')}\n"
            response += "\n"
        
        if approved:
            response += f"‚úÖ **Confirmadas ({len(approved)}):**\n"
            for res in approved:
                response += f"‚Ä¢ {res.space_type} - {res.date.strftime('%d/%m/%Y')}\n"
        
        return response.strip()

class AIClaimClassifier:
    """Clasificador autom√°tico de reclamos con IA"""
    
    def __init__(self):
        self.categorias = {
            'seguridad': {
                'keywords': ['robo', 'seguridad', 'alarma', 'intruso', 'guardia', 'camara', 'iluminacion nocturna', 'port√≥n'],
                'prioridad_base': 'alta',
                'area_responsable': 'Seguridad',
                'tiempo_respuesta': '2 horas'
            },
            'mantenimiento': {
                'keywords': ['reparacion', 'roto', 'arreglar', 'mantenimiento', 'pintura', 'jardin', 'limpieza'],
                'prioridad_base': 'media',
                'area_responsable': 'Mantenimiento',
                'tiempo_respuesta': '24 horas'
            },
            'iluminacion': {
                'keywords': ['luz', 'iluminacion', 'foco', 'lampara', 'alumbrado', 'oscuro'],
                'prioridad_base': 'media',
                'area_responsable': 'Mantenimiento El√©ctrico',
                'tiempo_respuesta': '12 horas'
            },
            'espacios_comunes': {
                'keywords': ['quincho', 'pileta', 'cancha', 'playground', 'salon', 'espacio comun'],
                'prioridad_base': 'media',
                'area_responsable': 'Administraci√≥n',
                'tiempo_respuesta': '48 horas'
            },
            'administracion': {
                'keywords': ['expensa', 'factura', 'pago', 'documento', 'administracion', 'consorcio'],
                'prioridad_base': 'baja',
                'area_responsable': 'Administraci√≥n',
                'tiempo_respuesta': '72 horas'
            },
            'infraestructura': {
                'keywords': ['agua', 'gas', 'electricidad', 'cloaca', 'desague', 'fuga', 'corte'],
                'prioridad_base': 'alta',
                'area_responsable': 'Mantenimiento de Servicios',
                'tiempo_respuesta': '4 horas'
            }
        }
        
        self.urgencia_keywords = {
            'emergencia': ['emergencia', 'urgente', 'peligro', 'riesgo', 'accidente'],
            'alta': ['fuga', 'corte', 'robo', 'intruso', 'seguridad'],
            'media': ['roto', 'no funciona', 'problema'],
            'baja': ['consulta', 'solicitud', 'mejora', 'sugerencia']
        }

    def clasificar_reclamo(self, titulo, descripcion):
        """Clasifica autom√°ticamente un reclamo"""
        texto_completo = f"{titulo} {descripcion}".lower()
        
        # Detectar categor√≠a
        categoria_detectada = self._detectar_categoria(texto_completo)
        
        # Detectar prioridad
        prioridad_detectada = self._detectar_prioridad(texto_completo, categoria_detectada)
        
        # Generar sugerencias
        sugerencias = self._generar_sugerencias(categoria_detectada, prioridad_detectada)
        
        return {
            'categoria': categoria_detectada,
            'prioridad': prioridad_detectada,
            'area_responsable': self.categorias[categoria_detectada]['area_responsable'],
            'tiempo_respuesta': self.categorias[categoria_detectada]['tiempo_respuesta'],
            'sugerencias': sugerencias
        }

    def _detectar_categoria(self, texto):
        """Detecta la categor√≠a del reclamo"""
        scores = {}
        
        for categoria, info in self.categorias.items():
            score = sum(1 for keyword in info['keywords'] if keyword in texto)
            if score > 0:
                scores[categoria] = score
        
        if scores:
            return max(scores, key=scores.get)
        
        return 'administracion'  # Por defecto

    def _detectar_prioridad(self, texto, categoria):
        """Detecta la prioridad del reclamo"""
        # Verificar palabras de urgencia
        for nivel, keywords in self.urgencia_keywords.items():
            if any(keyword in texto for keyword in keywords):
                if nivel == 'emergencia':
                    return 'emergencia'
                return nivel
        
        # Usar prioridad base de la categor√≠a
        return self.categorias[categoria]['prioridad_base']

    def _generar_sugerencias(self, categoria, prioridad):
        """Genera sugerencias para el reclamo"""
        sugerencias = []
        
        if prioridad == 'emergencia':
            sugerencias.append("üö® Este reclamo ha sido marcado como EMERGENCIA")
            sugerencias.append("üìû Contacta inmediatamente a seguridad: +54 11 4444-5556")
        
        if categoria == 'seguridad':
            sugerencias.append("üõ°Ô∏è Aseg√∫rate de estar en un lugar seguro")
            sugerencias.append("üì∏ Si es posible, toma fotos como evidencia")
        
        elif categoria == 'infraestructura':
            sugerencias.append("üîß Cierra las llaves de paso si hay fuga de agua")
            sugerencias.append("‚ö° No toques instalaciones el√©ctricas da√±adas")
        
        elif categoria == 'mantenimiento':
            sugerencias.append("üì∑ Adjunta fotos del problema para acelerar la reparaci√≥n")
            sugerencias.append("üìç Especifica la ubicaci√≥n exacta del problema")
        
        return sugerencias

    def crear_respuesta_inteligente(self, clasificacion):
        """Crea una respuesta inteligente sobre la clasificaci√≥n"""
        categoria = clasificacion['categoria']
        prioridad = clasificacion['prioridad']
        area = clasificacion['area_responsable']
        tiempo = clasificacion['tiempo_respuesta']
        
        emojis = {
            'seguridad': 'üõ°Ô∏è',
            'mantenimiento': 'üîß',
            'iluminacion': 'üí°',
            'espacios_comunes': 'üèõÔ∏è',
            'administracion': 'üìã',
            'infraestructura': 'üîß'
        }
        
        prioridad_emojis = {
            'emergencia': 'üö®',
            'alta': 'üî¥',
            'media': 'üü°',
            'baja': 'üü¢'
        }
        
        response = f"""ü§ñ **An√°lisis Inteligente del Reclamo:**

{emojis.get(categoria, 'üìã')} **Categor√≠a**: {categoria.replace('_', ' ').title()}
{prioridad_emojis.get(prioridad, 'üü°')} **Prioridad**: {prioridad.title()}
üë• **√Årea Responsable**: {area}
‚è±Ô∏è **Tiempo de Respuesta**: {tiempo}

"""
        
        if clasificacion['sugerencias']:
            response += "üí° **Sugerencias:**\n"
            for sugerencia in clasificacion['sugerencias']:
                response += f"‚Ä¢ {sugerencia}\n"
        
        response += "\n‚úÖ Tu reclamo ha sido clasificado autom√°ticamente y derivado al √°rea correspondiente."
        
        return response
